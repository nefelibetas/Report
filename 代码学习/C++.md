####  移植和改变![image-20220320201954191](D:\报告\Report\pic\/image-20220320201954191.png)

例外：![image-20220320202016373](D:\报告\Report\pic\image-20220320202016373.png)

##### 条件编译

![image-20220320202154438](D:\报告\Report\pic\/image-20220320202154438.png)

#if 0 #endif 中的代码不编译

满足条件则预处理if后的内容，否则执行else。格式如上

#### 标准输入输出流

![image-20220320203005762](D:\报告\Report\pic\/image-20220320203005762.png) 

##### 标准名字空间

![image-20220320203345085](D:\报告\Report\pic\/image-20220320203345085.png) 

使用 using namespace std 方便

##### 输出语句

![image-20220320203055540](D:\报告\Report\pic\/image-20220320203055540.png) 

c中：printf ("");

C++中：std::cout<<变量名

![image-20220320203438437](D:\报告\Report\pic\/image-20220320203438437.png) 换行符\n可用endl代替

写法cout<<"hello world!"<<endl;(使用using namespace std时)

##### 输入语句

C中：scanf(""); gets();

C++中：std::cin>>变量名

同样可以使用名字空间简化

##### 文件输入输出流

**fstream**

使用![image-20220320204815272](D:\报告\Report\pic\/image-20220320204815272.png) 											![image-20220320205047420](D:\报告\Report\pic\/image-20220320205047420.png) 

ofsteam oF=fopen

oF<<表示从对应文件流出，相当于把变量写入文件

oF.close= fclose

iF>>表示从对应文件流入，相当于读取文件到变量中

ifsteam为输入

##### 引用变量

指变量的别名，定义时必须指明引用的变量。

下方2错误

![image-20220320205440919](D:\报告\Report\pic\/image-20220320205440919.png) 

引用变量类型名必须相同

下方1错误

![image-20220320205529634](D:\报告\Report\pic\/image-20220320205529634.png) 

###### 值行参

调用到形参进入函数使用时，不会对影响实参。

![image-20220320205909826](D:\报告\Report\pic\/image-20220320205909826.png) 

在函数内部对x，y修改时不会影响a，b。

结果都为3	4	3	4

而传递地址时

![image-20220320210310923](D:\报告\Report\pic\/image-20220320210310923.png) 

引用值形参（相当于取地址）

![image-20220320210507090](D:\报告\Report\pic\/image-20220320210507090.png) 

##### 函数的默认形参

![image-20220320210829353](D:\报告\Report\pic\/image-20220320210829353.png) 

例如：![image-20220320211008832](D:\报告\Report\pic\/image-20220320211008832.png) 结果：![image-20220320211050873](D:\报告\Report\pic\/image-20220320211050873.png) 

##### 函数重载

![image-20220320211217416](D:\报告\Report\pic\/image-20220320211217416.png) 

##### 函数模板

使用关键字

![image-20220320211844127](D:\报告\Report\pic\/image-20220320211844127.png) 

会自动产生对应类型的函数

![image-20220320211836473](D:\报告\Report\pic\/image-20220320211836473.png) 

##### string

声明：![image-20220320212339126](D:\报告\Report\pic\/image-20220320212339126.png) 

###### 一些函数

![image-20220320212511703](D:\报告\Report\pic\/image-20220320212511703.png) 

查询大小（长度）：![image-20220320212521207](D:\报告\Report\pic\/image-20220320212521207.png) 



制造新字符串：![image-20220320212604214](D:\报告\Report\pic\/image-20220320212604214.png) 

从s里的下标为1到下标为3的字符串中取出字符组成新的字符串



字符串拼接：![image-20220320212737214](D:\报告\Report\pic\/image-20220320212737214.png) 

直接使用加法即可达到拼接

 

查找特定字符串：![image-20220320212859462](D:\报告\Report\pic\/image-20220320212859462.png) 

查找如果有的话，返回第一个字符位置的指针。



字符串的插入：![image-20220320212948863](D:\报告\Report\pic\/image-20220320212948863.png) 

在s4字符串的下标为3的位置插入后边的字符串



##### vector

向量，类似数组，可以动态增长

头文件< vector > 

![image-20220320213324590](D:\报告\Report\pic\/image-20220320213324590.png) 

声明：![image-20220320213426382](D:\报告\Report\pic\/image-20220320213426382.png) 

###### 一些函数



在尾端插入：![image-20220320213443230](D:\报告\Report\pic\/image-20220320213443230.png) 在v向量组的尾端插入 25 13

弹出最后的元素：![image-20220320213628878](D:\报告\Report\pic\/image-20220320213628878.png)

 自动弹出最后的元素，结果：![image-20220320213654694](D:\报告\Report\pic\/image-20220320213654694.png) 



重新定义大小：![image-20220320213732381](D:\报告\Report\pic\/image-20220320213732381.png) 将向量组的大小重新定义为2

结果![image-20220320213814101](D:\报告\Report\pic\/image-20220320213814101.png) 

##### 指针

指针即为地址，**取地址符&可以获得变量的地址**

![image-20220320214059973](D:\报告\Report\pic\/image-20220320214059973.png) 

指针类型必须相同

###### 动态申请内存

在C中，用malloc动态申请内存，用free释放内存

但在c++中，可以使用![image-20220321083414254](D:\报告\Report\pic\/image-20220321083414254.png) new来替代

释放内存用delete![image-20220321083644509](D:\报告\Report\pic\/image-20220321083644509.png) 若不及时释放，则容易造成内存泄漏

![image-20220321084210173](D:\报告\Report\pic\/image-20220321084210173.png) 

#### 类和对象

![image-20220321084612421](D:\报告\Report\pic\/image-20220321084612421.png) 

![image-20220321084558669](D:\报告\Report\pic\/image-20220321084558669.png) 

![image-20220321084840166](D:\报告\Report\pic\/image-20220321084840166.png) 

两者不同：![image-20220321085226734](D:\报告\Report\pic\/image-20220321085226734.png) 

##### 特性

![image-20220321085444852](D:\报告\Report\pic\/image-20220321085444852.png) 

用struct 或者 class 定义类

不同：![image-20220321091714656](D:\报告\Report\pic\/image-20220321091714656.png) 

class内部成员不能在外侧随便调用；

解决方式：

![image-20220321091833714](D:\报告\Report\pic\/image-20220321091833714.png) 

缺点：其他函数可以任意修改

所以，一般操作为，让类内部函数进行公开,数据私有：![image-20220321092153786](D:\报告\Report\pic\/image-20220321092153786.png)（外部接口)

![image-20220321092318897](D:\报告\Report\pic\/image-20220321092318897.png) 

数据修改：![image-20220321092121529](D:\报告\Report\pic\/image-20220321092121529.png) 



![image-20220321085630300](D:\报告\Report\pic\/image-20220321085630300.png) 

与c不同，不需要关键字即可

![image-20220321085703171](D:\报告\Report\pic\/image-20220321085703171.png) 

##### 类的成员函数

函数定义在内部

![image-20220321090243109](D:\报告\Report\pic\/image-20220321090243109.png)

函数定义在外部时，必须加上对应的名字空间

![image-20220321090354860](D:\报告\Report\pic\/image-20220321090354860.png) 

##### this指针

在调用类内部的函数时，实际上有this指针保证调用时正确

##### 构造函数

在创造类对象时，会自动调用称为 构造函数 的的成员函数

![image-20220321092638721](D:\报告\Report\pic\/image-20220321092638721.png) 

默认构造内部无内容，并且不带参数：![image-20220321092654137](D:\报告\Report\pic\/image-20220321092654137.png) 

自己构造![image-20220321092912073](D:\报告\Report\pic\/image-20220321092912073.png) 调用时：![image-20220321092927481](D:\报告\Report\pic\/image-20220321092927481.png) 

没有默认构造函数时，无法创建数组。

##### 运算符重载

可以自己定义运算符

示例：重载<<达到可以直接输出类

![image-20220321093457337](D:\报告\Report\pic\/image-20220321093457337.png) 



##### 友元函数

![image-20220321093550384](D:\报告\Report\pic\/image-20220321093550384.png) 

可以使外部函数调用class内的私有内容

